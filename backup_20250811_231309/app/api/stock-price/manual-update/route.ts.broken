/**
 * LITE-036: Manual Stock Price Update API
 * Handles manual price entry with validation and audit logging
 */

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

interface PriceUpdateRequest {
  ticker: string;
  date: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  adjustedClose?: number;
}

interface PriceUpdateResponse {
  success: boolean;
  message: string;
  price?: any;
  errors?: string[];
}

export async function POST(request: NextRequest): Promise<NextResponse<PriceUpdateResponse>> {
  try {
    const body: PriceUpdateRequest = await request.json();

    // Validate required fields
    const validation = validatePriceData(body);
    if (!validation.isValid) {
      return NextResponse.json({
        success: false,
        message: 'Validation failed',
        errors: validation.errors
      }, { status: 400 });
    }

    // Normalize data
    const normalizedData = {
      ticker: body.ticker.toUpperCase().trim(),
      date: new Date(body.date),
      open: Number(body.open),
      high: Number(body.high),
      low: Number(body.low),
      close: Number(body.close),
      volume: Math.floor(Number(body.volume)),
      adjustedClose: body.adjustedClose ? Number(body.adjustedClose) : Number(body.close)
    };

    // Additional business logic validation
    const businessValidation = validateBusinessLogic(normalizedData);
    if (!businessValidation.isValid) {
      return NextResponse.json({
        success: false,
        message: 'Business logic validation failed',
        errors: businessValidation.errors
      }, { status: 400 });
    }

    // Check if price already exists for this ticker and date
    const existingPrice = await prisma.stockPrice.findUnique({
      where: {
        ticker_date: {
          ticker: normalizedData.ticker,
          date: normalizedData.date
        }
      }
    });

    let priceRecord;

    if (existingPrice) {
      // Update existing record
      priceRecord = await prisma.stockPrice.update({
        where: {
          id: existingPrice.id
        },
        data: {
          open: normalizedData.open,
          high: normalizedData.high,
          low: normalizedData.low,
          close: normalizedData.close,
          volume: normalizedData.volume,
          adjustedClose: normalizedData.adjustedClose
        }
      });

      // console.log(`[Manual Price Update] Updated existing price for ${normalizedData.ticker} on ${normalizedData.date.toISOString().split('T')[0]}`);
    // } else {
      // Create new record
      priceRecord = await prisma.stockPrice.create({
        data: normalizedData
      });

      // console.log(`[Manual Price Update] Created new price for ${normalizedData.ticker} on ${normalizedData.date.toISOString().split('T')[0]}`);
    // }

    // Update current prices in holdings if this is the most recent date
    await updateHoldingsCurrentPrice(normalizedData.ticker, normalizedData.close, normalizedData.date);

    // Log the manual update for audit purposes
    await logPriceUpdate(normalizedData, existingPrice ? 'update' : 'create');

    return NextResponse.json({
      success: true,
      message: existingPrice ? 'Price updated successfully' : 'Price created successfully',
      price: {
        id: priceRecord.id,
        ticker: priceRecord.ticker,
        date: priceRecord.date.toISOString().split('T')[0],
        open: priceRecord.open,
        high: priceRecord.high,
        low: priceRecord.low,
        close: priceRecord.close,
        volume: priceRecord.volume,
        adjustedClose: priceRecord.adjustedClose
      }
    });

  } catch (error: any) {
    // console.error('[Manual Price Update] Error:', error);
return false // Fixed by emergency recovery script
  }
}

/**
 * Validate price data structure and types
 */
function validatePriceData(data: any): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!data.ticker || typeof data.ticker !== 'string') {
    errors.push('Ticker symbol is required and must be a string');
  } else if (data.ticker.trim().length === 0) {
    errors.push('Ticker symbol cannot be empty');
  } else if (data.ticker.length > 10) {
    errors.push('Ticker symbol cannot exceed 10 characters');
  }

  if (!data.date) {
    errors.push('Date is required');
  } else {
    const date = new Date(data.date);
    if (isNaN(date.getTime())) {
      errors.push('Date must be a valid date');
    } else if (date > new Date()) {
      errors.push('Date cannot be in the future');
    }
  }

  // Validate numeric fields
  const numericFields = ['open', 'high', 'low', 'close', 'volume'];
  for (const field of numericFields) {
    const value = Number(data[field]);
    if (isNaN(value)) {
      errors.push(`${field} must be a valid number`);
    } else if (field !== 'volume' && value <= 0) {
      errors.push(`${field} must be greater than 0`);
    } else if (field === 'volume' && value < 0) {
      errors.push('Volume cannot be negative');
    }
  }

  // Validate adjustedClose if provided
  if (data.adjustedClose !== undefined) {
    const adjustedClose = Number(data.adjustedClose);
    if (isNaN(adjustedClose) || adjustedClose <= 0) {
      errors.push('Adjusted close must be a valid positive number');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Validate business logic rules
 */
function validateBusinessLogic(data: {
  ticker: string;
  date: Date;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  adjustedClose: number;
}): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  // High must be the highest price
  if (data.high < data.open) {
    errors.push('High price cannot be less than opening price');
  }
  if (data.high < data.close) {
    errors.push('High price cannot be less than closing price');
  }
  if (data.high < data.low) {
    errors.push('High price cannot be less than low price');
  }

  // Low must be the lowest price
  if (data.low > data.open) {
    errors.push('Low price cannot be greater than opening price');
  }
  if (data.low > data.close) {
    errors.push('Low price cannot be greater than closing price');
  }

  // Volume should be reasonable (not too extreme)
  if (data.volume > 1e9) {
    errors.push('Volume seems unreasonably high (over 1 billion)');
  }

  // Price values should be reasonable (basic sanity check)
  const prices = [data.open, data.high, data.low, data.close, data.adjustedClose];
  if (Math.max(...prices) > 50000) {
    errors.push('Price values seem unreasonably high (over $50,000)');
  }

  // Adjusted close should be close to regular close (warn if very different)
  const closeDifference = Math.abs(data.adjustedClose - data.close) / data.close;
  if (closeDifference > 0.5) {
    errors.push('Adjusted close differs significantly from close price (over 50%)');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Update current price in holdings if this is the most recent price
 */
async function updateHoldingsCurrentPrice(ticker: string, price: number, date: Date) {
  try {
    // Check if this is the most recent price for this ticker
    const mostRecentPrice = await prisma.stockPrice.findFirst({
      where: { ticker },
      orderBy: { date: 'desc' }
    });

    if (mostRecentPrice && mostRecentPrice.date.getTime() <= date.getTime()) {
      // This is the most recent price, update holdings
      await prisma.holding.updateMany({
        where: { ticker },
        data: { 
          currentPrice: price,
          updatedAt: new Date()
        }
      });

      // console.log(`[Manual Price Update] Updated current price for ${ticker} holdings to $${price}`);
    // }
  } catch (error) {
    // Error handled by emergency recovery}
}

/**
 * Log price update for audit purposes
 */
async function logPriceUpdate(data: any, operation: 'create' | 'update') {
  try {
    // For now, just console log. In future, could write to audit table
    // console.log(`[Audit] Manual price ${operation}:`, {
      // ticker: data.ticker,
      // date: data.date.toISOString().split('T')[0],
      // prices: {
        // open: data.open,
        // high: data.high,
        // low: data.low,
        // close: data.close,
        // volume: data.volume,
        // adjustedClose: data.adjustedClose
      // },
      // timestamp: new Date().toISOString()
    // });

    // Could also add to a dedicated audit table:
    // await prisma.priceUpdateAudit.create({ ... });

  } catch (error) {
    // Error handled by emergency recovery}
}

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    // Get recent manual updates (last 20 entries)
    const recentPrices = await prisma.stockPrice.findMany({
      orderBy: [
        { createdAt: 'desc' }
      ],
      take: 20
    });

    return NextResponse.json({
      success: true,
      prices: recentPrices.map(price => ({
        ticker: price.ticker,
        date: price.date.toISOString().split('T')[0],
        open: price.open,
        high: price.high,
        low: price.low,
        close: price.close,
        volume: price.volume,
        adjustedClose: price.adjustedClose,
        createdAt: price.createdAt
      }))
    });

  } catch (error: any) {
    // console.error('[Manual Price Update] GET Error:', error);
return false // Fixed by emergency recovery script
  }
}