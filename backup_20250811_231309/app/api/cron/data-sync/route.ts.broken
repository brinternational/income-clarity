/**
 * Cron Job: Data Sync
 * Synchronizes external data and updates materialized views
 * Runs every hour to keep data fresh
 */

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { LocalModeUtils } from '@/lib/config/local-mode'
import { multiLevelCache } from '@/lib/cache-service'

export const runtime = 'nodejs'
export const maxDuration = 300 // 5 minutes max

interface DataSyncStats {
  stockPricesUpdated: number
  portfoliosRefreshed: number
  dividendDataUpdated: number
  cacheInvalidated: number
  errors: number
  totalTime: number
}

export async function GET(request: NextRequest) {
  const startTime = Date.now()
  const stats: DataSyncStats = {
    stockPricesUpdated: 0,
    portfoliosRefreshed: 0,
    dividendDataUpdated: 0,
    cacheInvalidated: 0,
    errors: 0,
    totalTime: 0
  }
  
  try {
    // LOCAL_MODE: Skip data sync
    if (LocalModeUtils.isEnabled()) {
      LocalModeUtils.log('Cron Data Sync - LOCAL_MODE: Skipping data sync')
      return NextResponse.json({ 
        success: true, 
        message: 'Skipped in LOCAL_MODE',
        stats,
        processingTime: Date.now() - startTime 
      })
    }
    
    // Verify this is a legitimate cron request
    const authHeader = request.headers.get('authorization')
    const expectedAuth = `Bearer ${process.env.CRON_SECRET}`
    
    if (process.env.NODE_ENV === 'production' && (!authHeader || authHeader !== expectedAuth)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Initialize Supabase client
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      return NextResponse.json({ 
        error: 'Missing Supabase configuration' 
      }, { status: 500 })
    }

    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    )

    // console.log('[CRON] Starting data synchronization...')
// 
    // 1. Refresh materialized views
    try {
      // console.log('[CRON] Refreshing materialized views...')
      // const { error: viewError } = await supabase.rpc('refresh_user_materialized_views')
      
      if (viewError) {
        throw new Error(`Materialized views refresh failed: ${viewError.message}`)
      }
      
      stats.portfoliosRefreshed = 1
      // console.log('[CRON] ✅ Materialized views refreshed')
    // } catch (error) {
      stats.errors++
      // console.error('[CRON] ❌ Materialized views refresh failed:', error)
    // }

    // 2. Update stock price cache (call internal API)
    try {
      // console.log('[CRON] Updating stock price cache...')
      // 
      // Get list of unique symbols from active portfolios
      const { data: symbols, error: symbolsError } = await supabase
        .from('holdings')
        .select('symbol')
        .not('symbol', 'is', null)
        .limit(100) // Limit to avoid API rate limits
      
      if (symbolsError) {
        throw new Error(`Failed to fetch symbols: ${symbolsError.message}`)
      }

      const uniqueSymbols = [...new Set(symbols?.map(s => s.symbol) || [])]
      
      if (uniqueSymbols.length > 0) {
        // Call stock price API to refresh cache
        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
        const stockPriceUrl = `${baseUrl}/api/cron/stock-price-cache`
        
        const response = await fetch(stockPriceUrl, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${process.env.CRON_SECRET}`
          }
        })
        
        if (response.ok) {
          const result = await response.json()
          stats.stockPricesUpdated = result.updatedCount || 0
          // console.log(`[CRON] ✅ Stock prices updated for ${stats.stockPricesUpdated} symbols`)
        // } else {
          throw new Error(`Stock price update failed: ${response.statusText}`)
        }
      } else {
        // console.log('[CRON] No symbols found to update')
      // }
    } catch (error) {
      stats.errors++
      // console.error('[CRON] ❌ Stock price update failed:', error)
    // }

    // 3. Update dividend announcement data
    try {
      // console.log('[CRON] Updating dividend data...')
      // 
      // Get upcoming dividend announcements (simplified mock for now)
      const { data: portfolios, error: portfolioError } = await supabase
        .from('portfolios')
        .select('id, user_id')
        .eq('is_primary', true)
        .limit(50)
      
      if (portfolioError) {
        throw new Error(`Failed to fetch portfolios: ${portfolioError.message}`)
      }

      // For each portfolio, check for dividend updates
      // This is a placeholder - in production you'd integrate with dividend data API
      stats.dividendDataUpdated = portfolios?.length || 0
      // console.log(`[CRON] ✅ Dividend data updated for ${stats.dividendDataUpdated} portfolios`)
      // 
    } catch (error) {
      stats.errors++
      // console.error('[CRON] ❌ Dividend data update failed:', error)
    // }

    // 4. Invalidate related caches
    try {
      // console.log('[CRON] Invalidating caches...')
      // 
      // Invalidate performance and income caches since data has been updated
      const patterns = [
        'sc:*:performance:*',
        'sc:*:income:*',
        'sc:*:strategy:*',
        'stock-price:*'
      ]
      
      let totalInvalidated = 0
      for (const pattern of patterns) {
        const invalidated = await multiLevelCache.invalidate(pattern, {
          cascadeL1: true,
          cascadeL2: true,
          cascadeL3: false
        })
        totalInvalidated += invalidated
      }
      
      stats.cacheInvalidated = totalInvalidated
      // console.log(`[CRON] ✅ Cache invalidated: ${stats.cacheInvalidated} entries`)
      // 
    } catch (error) {
      stats.errors++
      // console.error('[CRON] ❌ Cache invalidation failed:', error)
    // }

    // 5. Update database statistics
    try {
      // console.log('[CRON] Updating database statistics...')
      // const { error: statsError } = await supabase.rpc('update_table_statistics')
      
      if (statsError) {
        // console.error('[CRON] Database statistics update failed:', statsError.message)
      // } else {
        // console.log('[CRON] ✅ Database statistics updated')
      // }
    } catch (error) {
      // console.error('[CRON] Database statistics update failed:', error)
    // }

    stats.totalTime = Date.now() - startTime

    // console.log(`[CRON] Data synchronization completed in ${stats.totalTime}ms:
  // - Stock prices updated: ${stats.stockPricesUpdated}
  // - Portfolios refreshed: ${stats.portfoliosRefreshed}
  // - Dividend data updated: ${stats.dividendDataUpdated}
  // - Cache entries invalidated: ${stats.cacheInvalidated}
  // - Errors: ${stats.errors}`)

    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      stats,
      message: `Data sync completed with ${stats.errors} errors`
    })

  } catch (error) {
    stats.errors++
    stats.totalTime = Date.now() - startTime
    // console.error('[CRON] Data synchronization failed:', error)
    // 
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      stats,
      timestamp: new Date().toISOString()
    }, { status: 500 })
  }
}