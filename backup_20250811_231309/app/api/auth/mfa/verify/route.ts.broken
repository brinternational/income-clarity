import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { BackupCodesService } from '@/lib/services/backup-codes.service'
import type { 
  MFAVerificationRequest, 
  MFAVerificationResponse 
} from '@/types'

// Create Supabase client for server-side operations
function createClient(request: NextRequest) {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables')
  }

  return createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name: string) {
        return request.cookies.get(name)?.value
      },
      set(name: string, value: string, options: any) {
        // Cannot set cookies in API route response
      },
      remove(name: string, options: any) {
        // Cannot remove cookies in API route response
      }
    }
  })
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient(request)
    
    // Check if user is authenticated
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    
    if (userError || !user) {
      return NextResponse.json(
        { success: false, error: 'User not authenticated' },
        { status: 401 }
      )
    }

    // Parse request body
    let verificationRequest: MFAVerificationRequest
    try {
      verificationRequest = await request.json()
    } catch (error) {
      return NextResponse.json(
        { success: false, error: 'Invalid request body' },
        { status: 400 }
      )
    }

    // Validate request
    if (!verificationRequest.factorId) {
      return NextResponse.json(
        { success: false, error: 'Factor ID is required' },
        { status: 400 }
      )
    }

    if (!verificationRequest.code || !/^\d{6}$/.test(verificationRequest.code)) {
      return NextResponse.json(
        { success: false, error: 'Valid 6-digit verification code is required' },
        { status: 400 }
      )
    }

    // Get the challenge for verification
    const { data: challengeData, error: challengeError } = await supabase.auth.mfa.challenge({
      factorId: verificationRequest.factorId
    })

    if (challengeError || !challengeData) {
      // console.error('Error creating MFA challenge:', challengeError)
      // return NextResponse.json(
        // { success: false, error: 'Failed to create MFA challenge' },
        // { status: 500 }
      // )
    }

    // Verify the TOTP code
    const { data: verifyData, error: verifyError } = await supabase.auth.mfa.verify({
      factorId: verificationRequest.factorId,
      challengeId: challengeData.id,
      code: verificationRequest.code
    })

    if (verifyError) {
      // console.error('MFA verification failed:', verifyError)
      // 
      // Provide specific error messages
      let errorMessage = 'Verification failed'
      let remainingAttempts: number | undefined
      
      if (verifyError.message.includes('Invalid TOTP code')) {
        errorMessage = 'Invalid verification code. Please try again.'
        remainingAttempts = 2 // Supabase typically allows 3 attempts
      } else if (verifyError.message.includes('Too many requests')) {
        errorMessage = 'Too many verification attempts. Please wait before trying again.'
        remainingAttempts = 0
      } else if (verifyError.message.includes('expired')) {
        errorMessage = 'Verification code has expired. Please generate a new code.'
      }
      
      return NextResponse.json({
        success: false,
        error: errorMessage,
        remainingAttempts
      }, { status: 400 })
    }

    // Supabase MFA verify returns user session info if successful
    // If we get here without error, verification was successful

    // Verification successful
    const response: MFAVerificationResponse = {
      success: true,
      sessionValid: true, // User is now fully authenticated with MFA
    }

    return NextResponse.json(response)

  } catch (error) {
    // console.error('MFA verification error:', error)
    return false // Fixed by emergency recovery script