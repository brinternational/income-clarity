/**
 * Admin Queue Management API
 * Provides endpoints for monitoring and managing job queues
 */

import { NextRequest, NextResponse } from 'next/server';
import { jobScheduler } from '../../../../lib/services/jobs/job-scheduler.service';
import { getQueueSystemHealth } from '../../../../lib/services/jobs/queue-config';
import { logger } from '../../../../lib/logger';

// Authentication middleware (implement according to your auth system)
async function validateAdminAccess(request: NextRequest): Promise<boolean> {
  try {
    // Get authorization header
    const authHeader = request.headers.get('authorization');
    
    if (!authHeader?.startsWith('Bearer ')) {
      return false;
    }

    const token = authHeader.substring(7);
    
    // Validate JWT token and check admin role
    // This is a simplified check - implement according to your auth system
    const adminKey = process.env.ADMIN_API_KEY;
    if (!adminKey || token !== adminKey) {
      return false;
    }

    return true;

  } catch (error) {
    logger.error('Admin access validation failed', { error: error.message });
    return false;
  }
}

/**
 * GET /api/admin/queue - Get queue statistics and health
 */
export async function GET(request: NextRequest) {
  try {
    // Validate admin access
    if (!(await validateAdminAccess(request))) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const url = new URL(request.url);
    const action = url.searchParams.get('action');
    const queueName = url.searchParams.get('queue');

    switch (action) {
      case 'health':
        return await handleHealthCheck();
        
      case 'stats':
        return await handleGetStats(queueName);
        
      case 'failed-jobs':
        return await handleGetFailedJobs(queueName, url.searchParams);
        
      case 'job-details':
        return await handleGetJobDetails(queueName, url.searchParams.get('jobId'));
        
      default:
        return await handleGetOverview();
    }

  } catch (error) {
    logger.error('Admin queue API error', { error: error.message });
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/admin/queue - Queue management actions
 */
export async function POST(request: NextRequest) {
  try {
    // Validate admin access
    if (!(await validateAdminAccess(request))) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { action, queueName, jobId, data } = body;

    switch (action) {
      case 'add-job':
        return await handleAddJob(queueName, data);
        
      case 'retry-job':
        return await handleRetryJob(queueName, jobId);
        
      case 'remove-job':
        return await handleRemoveJob(queueName, jobId);
        
      case 'clear-queue':
        return await handleClearQueue(queueName, data?.jobState);
        
      case 'pause-queue':
        return await handlePauseQueue(queueName);
        
      case 'resume-queue':
        return await handleResumeQueue(queueName);
        
      case 'retry-failed':
        return await handleRetryAllFailed(queueName);
        
      default:
        return NextResponse.json(
          { error: 'Unknown action' },
          { status: 400 }
        );
    }

  } catch (error) {
    logger.error('Admin queue POST API error', { error: error.message });
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * Handle health check
 */
async function handleHealthCheck() {
  try {
    const [schedulerHealth, systemHealth] = await Promise.all([
      jobScheduler.healthCheck(),
      getQueueSystemHealth()
    ]);

    return NextResponse.json({
      timestamp: new Date().toISOString(),
      scheduler: schedulerHealth,
      system: systemHealth,
      overall: schedulerHealth.status === 'healthy' && systemHealth.redis ? 'healthy' : 'unhealthy'
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message,
      overall: 'unhealthy'
    }, { status: 500 });
  }
}

/**
 * Handle get queue statistics
 */
async function handleGetStats(queueName?: string) {
  try {
    if (queueName) {
      const stats = await jobScheduler.getQueueStats(queueName);
      return NextResponse.json({
        queueName,
        stats,
        timestamp: new Date().toISOString()
      });
    } else {
      const allStats = await jobScheduler.getAllQueueStats();
      return NextResponse.json({
        queues: allStats,
        timestamp: new Date().toISOString()
      });
    }

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle get failed jobs
 */
async function handleGetFailedJobs(queueName?: string, searchParams?: URLSearchParams) {
  try {
    if (!queueName) {
      return NextResponse.json({
        error: 'Queue name is required'
      }, { status: 400 });
    }

    const start = parseInt(searchParams?.get('start') || '0');
    const end = parseInt(searchParams?.get('end') || '50');

    const failedJobs = await jobScheduler.getFailedJobs(queueName, start, end);

    const jobs = failedJobs.map(job => ({
      id: job.id,
      name: job.name,
      data: job.data,
      opts: job.opts,
      attemptsMade: job.attemptsMade,
      processedOn: job.processedOn,
      failedReason: job.failedReason,
      stacktrace: job.stacktrace,
      timestamp: job.timestamp
    }));

    return NextResponse.json({
      queueName,
      jobs,
      pagination: {
        start,
        end,
        total: jobs.length
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle get job details
 */
async function handleGetJobDetails(queueName?: string, jobId?: string) {
  try {
    if (!queueName || !jobId) {
      return NextResponse.json({
        error: 'Queue name and job ID are required'
      }, { status: 400 });
    }

    // This would need to be implemented in the job scheduler service
    // For now, return a placeholder response
    return NextResponse.json({
      queueName,
      jobId,
      message: 'Job details endpoint not implemented yet'
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle get overview
 */
async function handleGetOverview() {
  try {
    const [allStats, health] = await Promise.all([
      jobScheduler.getAllQueueStats(),
      jobScheduler.healthCheck()
    ]);

    // Calculate totals
    const totals = Object.values(allStats).reduce((acc: any, stats: any) => {
      if (stats.error) return acc;
      
      return {
        waiting: acc.waiting + (stats.waiting || 0),
        active: acc.active + (stats.active || 0),
        completed: acc.completed + (stats.completed || 0),
        failed: acc.failed + (stats.failed || 0),
        delayed: acc.delayed + (stats.delayed || 0),
        paused: acc.paused + (stats.paused || 0),
      };
    }, {
      waiting: 0,
      active: 0,
      completed: 0,
      failed: 0,
      delayed: 0,
      paused: 0,
    });

    return NextResponse.json({
      overview: {
        totalJobs: totals.waiting + totals.active + totals.completed + totals.failed + totals.delayed,
        activeJobs: totals.active,
        failedJobs: totals.failed,
        completedJobs: totals.completed,
        waitingJobs: totals.waiting,
        delayedJobs: totals.delayed,
        pausedJobs: totals.paused,
      },
      queues: allStats,
      health: health.status,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle add job
 */
async function handleAddJob(queueName: string, data: any) {
  try {
    if (!queueName || !data) {
      return NextResponse.json({
        error: 'Queue name and data are required'
      }, { status: 400 });
    }

    const { jobType, jobData, options = {} } = data;

    const job = await jobScheduler.addJob(queueName, jobType, jobData, options);

    return NextResponse.json({
      success: true,
      job: {
        id: job.id,
        name: job.name,
        queueName,
        data: job.data,
        opts: job.opts
      },
      message: 'Job added successfully'
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle retry job
 */
async function handleRetryJob(queueName: string, jobId: string) {
  try {
    if (!queueName || !jobId) {
      return NextResponse.json({
        error: 'Queue name and job ID are required'
      }, { status: 400 });
    }

    const success = await jobScheduler.retryJob(queueName, jobId);

    if (success) {
      return NextResponse.json({
        success: true,
        message: 'Job retried successfully'
      });
    } else {
      return NextResponse.json({
        error: 'Job not found or cannot be retried'
      }, { status: 404 });
    }

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle remove job
 */
async function handleRemoveJob(queueName: string, jobId: string) {
  try {
    if (!queueName || !jobId) {
      return NextResponse.json({
        error: 'Queue name and job ID are required'
      }, { status: 400 });
    }

    const success = await jobScheduler.removeJob(queueName, jobId);

    if (success) {
      return NextResponse.json({
        success: true,
        message: 'Job removed successfully'
      });
    } else {
      return NextResponse.json({
        error: 'Job not found'
      }, { status: 404 });
    }

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle clear queue
 */
async function handleClearQueue(queueName: string, jobState = 'completed') {
  try {
    if (!queueName) {
      return NextResponse.json({
        error: 'Queue name is required'
      }, { status: 400 });
    }

    const cleared = await jobScheduler.clearQueue(queueName, jobState as any);

    return NextResponse.json({
      success: true,
      cleared,
      message: `Cleared ${cleared} ${jobState} jobs from ${queueName}`
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle pause queue
 */
async function handlePauseQueue(queueName: string) {
  try {
    if (!queueName) {
      return NextResponse.json({
        error: 'Queue name is required'
      }, { status: 400 });
    }

    await jobScheduler.pauseQueue(queueName);

    return NextResponse.json({
      success: true,
      message: `Queue ${queueName} paused successfully`
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle resume queue
 */
async function handleResumeQueue(queueName: string) {
  try {
    if (!queueName) {
      return NextResponse.json({
        error: 'Queue name is required'
      }, { status: 400 });
    }

    await jobScheduler.resumeQueue(queueName);

    return NextResponse.json({
      success: true,
      message: `Queue ${queueName} resumed successfully`
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}

/**
 * Handle retry all failed jobs in a queue
 */
async function handleRetryAllFailed(queueName: string) {
  try {
    if (!queueName) {
      return NextResponse.json({
        error: 'Queue name is required'
      }, { status: 400 });
    }

    // Get failed jobs and retry them
    const failedJobs = await jobScheduler.getFailedJobs(queueName, 0, 1000);
    
    let retriedCount = 0;
    for (const job of failedJobs) {
      if (job.id) {
        const success = await jobScheduler.retryJob(queueName, job.id.toString());
        if (success) {
          retriedCount++;
        }
      }
    }

    return NextResponse.json({
      success: true,
      retriedCount,
      totalFailed: failedJobs.length,
      message: `Retried ${retriedCount} out of ${failedJobs.length} failed jobs`
    });

  } catch (error) {
    return NextResponse.json({
      error: error.message
    }, { status: 500 });
  }
}